# Java-course
Практические задания:
I OOP-basic
1. Создать классы Собака, Домашний Кот, Тигр, Животное (можете добавить два-три своих класса)
2. Животные могут бежать и плыть В качестве аргумента каждому метаду передается длина препятствия
3. У каждого животного есть ограничения на действия (бег кот — 200 м. собака — 500 м; 
   плавание кот — не умеет плавать, собака — 10 м) Результатом выполнения действия будет печать 
   в консоль Например  dogBobik.run(1S0); -> 'Бобик пробежал 150 м'
4. Создать один массив с животными и заставляете их по очереди пробежать дистанцию и проплыть.
5. * Добавить подсчет созданных Домашних Котов Тигров Собак Животных

- в пакете animalRefactor показано отличное решение с сокращением кода

II OOP-advanced

Оработка прктических навыков по работе с интерфейсами 
1. Продолжаем работать с участниками и выполнением действий Создайте три класса Человек,
   Кот, Робот которые не наследуются от одного класса Эти классы должны уметь бегать и прыгать
   все также с выводом информации о действии в консоль
2. Создайте два класса беговая дорожка и стена, при прохождении через которые, участники должны выполнять
   соответствующие действия (бежать или прыгать) результат выполнения печатаем в консоль (успешно пробежал,
    не смог пробежать и тд) у препятствий есть длина (для дорожки) или высота (для стены), а участников ограничения 
    на бег и прыжки.
3. Создайте два массива с Участниками и препятствияии и заставьте всех участников пройти этот набор препятствий.
   Если участник не смог пройти одно из препятствий, то дальше по списку он препятствий не идет

III Exception
 
 1. Создайте исключения: MyArraySizeException (неправильный размер массива), 
    и MyArrayDataException (в ячейке массива лежит что-то не то);
 2. Напишите метод, на вход которого подаётся двумерный строковый массив (String[][]) 
    размером 4x4. При подаче массива другого размера необходимо бросить исключение 
    MyArraySizeException.
 3. Далее метод должен пройтись по всем элементам массива, преобразовать в int и просуммировать. 
    Если в каком-то элементе массива преобразование не удалось (например, в ячейке лежит символ или текст вместо числа), 
    должно быть брошено исключение MyArrayDataException с детализацией, в какой именно ячейке лежат неверные данные. 
    Расчет данных для этой матрицы прекращается.
 4. В методе main() нужно вызвать полученный метод, обработать возможные исключения MySizeArrayException и 
    MyArrayDataException и вывести результат расчёта. Заметка: для  преобразования  строки  в  число  можно  
    использовать  метод класса  Integer: Integer.valueOf("l")
    
IV Collection

1.  Написать метод, который меняет два элемента массива местами (массив может быть любого ссылочного типа).
2.  Написать метод, который преобразует массив в ArrayList.
3. Задача:</p>
a. Даны классы Fruit -> Apple, Orange.</p>
b. Класс Box, в который можно складывать фрукты. Коробки условно сортируются по типу  фрукта, поэтому в одну коробку нельзя сложить и яблоки, и апельсины.</p>
c. Для хранения фруктов внутри коробки можно использовать ArrayList.</p>
d. Написать метод getWeight(), который высчитывает вес коробки. Задать вес одного  фрукта и их количество: вес яблока — 1.0f, апельсина — 1.5f (единицы измерения не
    важны).</p>
e. Внутри класса Box написать метод Compare, который позволяет сравнить текущую  коробку с той, которую подадут в Compare в качестве параметра. True, если их массы
    равны, False — в противном случае. Можно сравнивать коробки с яблоками и  апельсинами.</p>
f. Написать метод, который позволяет пересыпать фрукты из текущей коробки в другую.</p>
    Помним про сортировку фруктов: нельзя высыпать яблоки в коробку с апельсинами.</p>
 Соответственно, в текущей коробке фруктов не остаётся, а в другую перекидываются
 объекты, которые были в первой.</p>
g. Не забываем про метод добавления фрукта в коробку.</p>

V Collection

1 Создать массив с набором слов (10-20 слов, должны встречаться повторяющиеся). Найти и
вывести список уникальных слов, из которых состоит массив (дубликаты не считаем).
Посчитать, сколько раз встречается каждое слово.</p>
2 Написать простой класс Телефонный Справочник, который хранит в себе список фамилий и
телефонных номеров. В этот телефонный справочник с помощью метода add() можно
добавлять записи, а с помощью метода get() искать номер телефона по фамилии. Следует
учесть, что под одной фамилией может быть несколько телефонов (в случае однофамильцев),
тогда при запросе такой фамилии должны выводиться все телефоны. Желательно не добавлять
лишний функционал (дополнительные поля (имя, отчество, адрес), взаимодействие с пользователем
через консоль и т.д). Консоль использовать только для вывода результатов проверки телефонного
справочника.

VI Multithreading

1. Необходимо написать два метода, которые делают следующее:
1) Создают одномерный длинный массив, например:
static final int SIZE = 10 000 000 ;
static final int HALF = size / 2 ;
float [] arr = new float [ size ].
2) Заполняют этот массив единицами.
3) Засекают время выполнения: long a = System.currentTimeMillis().
4) Проходят по всему массиву и для каждой ячейки считают новое значение по формуле:
arr[ i ] = (f loat) (a rr[ i ] * Math. s in( 0 .2f + i / 5) * Math. c os( 0 .2f + i / 5) *
Math . cos ( 0.4f + i / 2 )).
5) Проверяется время окончания метода System.currentTimeMillis().
6) В консоль выводится время работы: System.out.println(System.currentTimeMillis() - a).
Отличие первого метода от второго:
● Первый просто бежит по массиву и вычисляет значения.
● Второй разбивает массив на два массива, в двух потоках высчитывает новые значения и
потом склеивает эти массивы обратно в один.
Пример деления одного массива на два:
● System.arraycopy(arr, 0, a1, 0, h);
● System.arraycopy(arr, h, a2, 0, h).
Пример обратной склейки:
● System.arraycopy(a1, 0, arr, 0, h);
● System.arraycopy(a2, 0, arr, h, h).
Примечание:
System.arraycopy() — копирует данные из одного массива в другой:
System.arraycopy(массив-источник, откуда начинаем брать данные из массива-источника,
массив-назначение, откуда начинаем записывать данные в массив-назначение, сколько ячеек
копируем)
По замерам времени:
Для первого метода надо считать время только на цикл расчета:
for ( int i = 0 ; i < size ; i ++) {
arr [ i ] = ( float )( arr [ i ] * Math . sin ( 0.2f + i / 5 ) * Math . cos ( 0.2f + i / 5 ) *
Math . cos ( 0.4f + i / 2 ));
}
Для второго метода замеряете время разбивки массива на 2, просчета каждого из двух массивов и
склейки.

VII Multithreading

1. Перенести приведенный ниже код в новый проект, где мы  организуем гонки.  
Все участники должны стартовать одновременно, несмотря на разное время  подготовки. В тоннель не 
может одновременно заехать больше половины участников (условность). 
Попробуйте все это синхронизировать. 
Когда все завершат гонку, нужно выдать объявление об окончании. 
Можно  корректировать  классы  (в  том  числе  конструктор  машин)  и  добавлять  объекты  классов  из 
пакета  util.concurrent. 
Обязательно  необходимо  объявить  победителя  гонки,  он должен быть только один, и это участник 
первым закончивший последний этап.

public class MainHomeWork_2 {

	private static final int CARS_COUNT = 4;

	public static void main(String[] args) {
		System.out.println("ВАЖНОЕ ОБЪЯВЛЕНИЕ >>> Подготовка!!!");
		Race race = new Race(new Road(60), new Tunnel( ), new Road(40));
		Car[] cars = new Car[CARS_COUNT];
		for (int i = 0; i < cars.length; i++) {
			cars[i] = new Car(race, 20 + (int) (Math.random() * 10));
		}
		for (int i = 0; i < cars.length; i++) {
			new Thread(cars[i]).start();
		}
		System.out.println("ВАЖНОЕ ОБЪЯВЛЕНИЕ >>> Гонка началась!!!");
		System.out.println("ВАЖНОЕ ОБЪЯВЛЕНИЕ >>> Гонка закончилась!!!");
	}
}
public class Car implements Runnable {
	private static int CARS_COUNT;

	static {
		CARS_COUNT = 0;
	}

	private Race race;
	private int speed;
	private String name;

	public String getName() {
		return name;
	}

	public int getSpeed() {
		return speed;
	}

	public Car(Race race, int speed) {
		this.race = race;
		this.speed = speed;
		CARS_COUNT++;
		this.name = "Участник #" + CARS_COUNT;
	}

	@Override
	public void run() {
		try {
			System.out.println(this.name + " готовится");
			Thread.sleep(500 + (int) (Math.random() * 800));
			System.out.println(this.name + " готов");
		} catch (Exception e) {
			e.printStackTrace();
		}
		for (int i = 0; i < race.getStages().size(); i++) {
			race.getStages().get(i).go(this);
		}
	}
}
public abstract class Stage {
	protected int length;
	protected String description;

	public String getDescription() {
		return description;
	}

	public abstract void go(Car c);
}

public class Road extends Stage {
	public Road(int length) {
		this.length = length;
		this.description = "Дорога " + length + " метров";
	}
	@Override
	public void go(Car c) {
		try {
			System.out.println(c.getName() + " начал этап: " + description);
			Thread.sleep(length / c.getSpeed() * 1000);
			System.out.println(c.getName() + " закончил этап: " + description);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

public class Tunnel extends Stage {

	public Tunnel() {
		this.length = 80;
		this.description = "Тоннель " + length + " метров";
	}

	@Override
	public void go(Car c) {
		try {
			try {
				System.out.println(c.getName() + " готовится к этапу(ждет): " +
					description);
				System.out.println(c.getName() + " начал этап: " + description);
				Thread.sleep(length / c.getSpeed() * 1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} finally {
				System.out.println(c.getName() + " закончил этап: " +
					description);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

public class Race {

	private ArrayList<Stage> stages;

	public ArrayList<Stage> getStages() {
		return stages;
	}

	public Race(Stage... stages) {
		this.stages = new ArrayList<>(Arrays.asList(stages));
	}

}


VIII Stream API

1. Создайте  массив  с  набором  слов,  и  с  помощью  Stream  API  найдите  наиболее  часто
   встречающееся; 
2. Создайте  массив  объектов  типа  Сотрудник (с полями Имя, Возраст, Зарплата) и вычислите
   среднюю зарплату сотрудника; 
3. Напишите метод, способный найти в массиве сотрудников из п. 2 найдите N самых старших  
   сотрудников  и  отпечатает  в  консоль  сообщение вида “N самых старших сотрудников зовут: имя1, имя2, имяN;”. 